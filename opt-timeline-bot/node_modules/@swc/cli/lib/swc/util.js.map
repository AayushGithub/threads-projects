{"version":3,"sources":["../../src/swc/util.ts"],"sourcesContent":["import * as swc from \"@swc/core\";\nimport slash from \"slash\";\nimport { mkdirSync, writeFileSync, promises } from \"fs\";\nimport { dirname, relative } from \"path\";\n\nexport async function exists(path: string): Promise<boolean> {\n  let pathExists = true;\n  try {\n    await promises.access(path);\n  } catch (err: any) {\n    pathExists = false;\n  }\n  return pathExists;\n}\n\nexport async function transform(\n  filename: string,\n  code: string,\n  opts: swc.Options,\n  sync: boolean,\n  outputPath: string | undefined\n): Promise<swc.Output> {\n  opts = {\n    filename,\n    ...opts,\n  };\n\n  if (outputPath) {\n    opts.outputPath = outputPath;\n  }\n\n  if (sync) {\n    return swc.transformSync(code, opts);\n  }\n\n  return swc.transform(code, opts);\n}\n\nexport async function compile(\n  filename: string,\n  opts: swc.Options,\n  sync: boolean,\n  outputPath: string | undefined\n): Promise<swc.Output | void> {\n  opts = {\n    ...opts,\n  };\n  if (outputPath) {\n    opts.outputPath = outputPath;\n  }\n\n  try {\n    const result = sync\n      ? swc.transformFileSync(filename, opts)\n      : await swc.transformFile(filename, opts);\n\n    if (result.map) {\n      // TODO: fix this in core\n      // https://github.com/swc-project/swc/issues/1388\n      const sourceMap = JSON.parse(result.map);\n      if (opts.sourceFileName) {\n        sourceMap[\"sources\"][0] = opts.sourceFileName;\n      }\n      if (opts.sourceRoot) {\n        sourceMap[\"sourceRoot\"] = opts.sourceRoot;\n      }\n      result.map = JSON.stringify(sourceMap);\n    }\n    return result;\n  } catch (err: any) {\n    if (!err.message.includes(\"ignored by .swcrc\")) {\n      throw err;\n    }\n  }\n}\n\nexport function outputFile(\n  output: swc.Output,\n  filename: string,\n  sourceMaps: undefined | swc.Options[\"sourceMaps\"]\n) {\n  const destDir = dirname(filename);\n  mkdirSync(destDir, { recursive: true });\n\n  let code = output.code;\n  if (output.map && sourceMaps !== \"inline\") {\n    // we've requested for a sourcemap to be written to disk\n    const fileDirName = dirname(filename);\n    const mapLoc = filename + \".map\";\n    code += \"\\n//# sourceMappingURL=\" + slash(relative(fileDirName, mapLoc));\n    writeFileSync(mapLoc, output.map);\n  }\n\n  writeFileSync(filename, code);\n}\n\nexport function assertCompilationResult<T>(\n  result: Map<string, Error | T>,\n  quiet = false\n): asserts result is Map<string, T> {\n  let compiled = 0;\n  let copied = 0;\n  let failed = 0;\n  for (const value of result.values()) {\n    if (value instanceof Error) {\n      failed++;\n    } else if ((value as unknown) === \"copied\") {\n      copied++;\n    } else if (value) {\n      compiled++;\n    }\n  }\n  if (!quiet && compiled + copied > 0) {\n    const copyResult = copied === 0 ? \" \" : ` (copied ${copied}) `;\n    console.info(\n      `Successfully compiled ${compiled} ${\n        compiled !== 1 ? \"files\" : \"file\"\n      }${copyResult}with swc.`\n    );\n  }\n\n  if (failed > 0) {\n    throw new Error(\n      `Failed to compile ${failed} ${failed !== 1 ? \"files\" : \"file\"} with swc.`\n    );\n  }\n}\n"],"names":["exists","transform","compile","outputFile","assertCompilationResult","path","pathExists","promises","access","err","filename","code","opts","sync","outputPath","swc","transformSync","result","transformFileSync","transformFile","map","sourceMap","JSON","parse","sourceFileName","sourceRoot","stringify","message","includes","output","sourceMaps","destDir","dirname","mkdirSync","recursive","fileDirName","mapLoc","slash","relative","writeFileSync","quiet","compiled","copied","failed","value","values","Error","copyResult","console","info"],"mappings":"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"}