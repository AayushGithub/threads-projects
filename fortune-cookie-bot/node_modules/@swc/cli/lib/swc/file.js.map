{"version":3,"sources":["../../src/swc/file.ts"],"sourcesContent":["import swc from \"@swc/core\";\nimport path from \"path\";\nimport slash from \"slash\";\nimport { SourceMapConsumer, SourceMapGenerator } from \"source-map\";\n\nimport { CliOptions } from \"./options\";\nimport { globSources, isCompilableExtension, watchSources } from \"./sources\";\nimport * as util from \"./util\";\n\nexport default async function ({\n  cliOptions,\n  swcOptions,\n}: {\n  cliOptions: CliOptions;\n  swcOptions: swc.Options;\n}) {\n  async function concatResults(\n    file: string,\n    ...results: swc.Output[]\n  ): Promise<swc.Output> {\n    let added = false;\n    const map = new SourceMapGenerator({\n      file,\n      sourceRoot: swcOptions.sourceRoot,\n    });\n\n    let code = \"\";\n    let offset = 0;\n\n    for (const result of results) {\n      code += result.code + \"\\n\";\n\n      if (result.map) {\n        added = true;\n\n        const consumer = await new SourceMapConsumer(result.map);\n        const sources = new Set<string>();\n\n        consumer.eachMapping(mapping => {\n          sources.add(mapping.source);\n          map.addMapping({\n            generated: {\n              line: mapping.generatedLine + offset,\n              column: mapping.generatedColumn,\n            },\n            original: {\n              line: mapping.originalLine,\n              column: mapping.originalColumn,\n            },\n            source: mapping.source,\n          });\n        });\n\n        sources.forEach(source => {\n          const content = consumer.sourceContentFor(source, true);\n          if (content !== null) {\n            map.setSourceContent(source, content);\n          }\n        });\n      }\n      offset = code.split(\"\\n\").length - 1;\n    }\n\n    if (!added) {\n      return { code };\n    }\n\n    return {\n      code,\n      map: JSON.stringify(map),\n    };\n  }\n\n  async function output(results: Iterable<swc.Output>) {\n    const file =\n      cliOptions.sourceMapTarget ||\n      path.basename(cliOptions.outFile || \"stdout\");\n\n    const result = await concatResults(file, ...results);\n\n    if (cliOptions.outFile) {\n      util.outputFile(result, cliOptions.outFile, swcOptions.sourceMaps);\n    } else {\n      process.stdout.write(result.code + \"\\n\");\n      if (result.map) {\n        const map = `//#sourceMappingURL=data:application/json;charset=utf-8;base64,${Buffer.from(\n          JSON.stringify(result.map),\n          \"utf8\"\n        ).toString(\"base64\")}`;\n        process.stdout.write(map);\n      }\n    }\n  }\n\n  async function handle(filename: string) {\n    const sourceFileName = slash(\n      cliOptions.outFile\n        ? path.relative(path.dirname(cliOptions.outFile), filename)\n        : filename\n    );\n    return await util.compile(\n      filename,\n      {\n        ...swcOptions,\n        sourceFileName,\n      },\n      cliOptions.sync,\n      cliOptions.outFile\n    );\n  }\n\n  async function getProgram(\n    previousResults: Map<string, swc.Output | Error> = new Map()\n  ) {\n    const results: typeof previousResults = new Map();\n\n    for (const filename of await globSources(\n      cliOptions.filenames,\n      cliOptions.includeDotfiles\n    )) {\n      if (isCompilableExtension(filename, cliOptions.extensions)) {\n        results.set(filename, previousResults.get(filename)!);\n      }\n    }\n    return results;\n  }\n\n  async function files() {\n    let results = await getProgram();\n    for (const filename of results.keys()) {\n      try {\n        const result = await handle(filename);\n        if (result) {\n          results.set(filename, result);\n        } else {\n          results.delete(filename);\n        }\n      } catch (err: any) {\n        console.error(err.message);\n        results.set(filename, err);\n      }\n    }\n\n    if (cliOptions.watch) {\n      const watcher = await watchSources(\n        cliOptions.filenames,\n        cliOptions.includeDotfiles\n      );\n      watcher.on(\"ready\", () => {\n        Promise.resolve()\n          .then(async () => {\n            util.assertCompilationResult(results, cliOptions.quiet);\n            await output(results.values());\n            if (!cliOptions.quiet) {\n              console.info(\"Watching for file changes.\");\n            }\n          })\n          .catch(err => {\n            console.error(err.message);\n          });\n      });\n      watcher.on(\"add\", async filename => {\n        if (isCompilableExtension(filename, cliOptions.extensions)) {\n          // ensure consistent insertion order when files are added\n          results = await getProgram(results);\n        }\n      });\n      watcher.on(\"unlink\", filename => {\n        results.delete(filename);\n      });\n      for (const type of [\"add\", \"change\"]) {\n        watcher.on(type, filename => {\n          if (!isCompilableExtension(filename, cliOptions.extensions)) {\n            return;\n          }\n\n          const start = process.hrtime();\n\n          handle(filename)\n            .then(async result => {\n              if (!result) {\n                results.delete(filename);\n                return;\n              }\n              results.set(filename, result);\n              util.assertCompilationResult(results, true);\n              await output(results.values());\n              if (!cliOptions.quiet) {\n                const [seconds, nanoseconds] = process.hrtime(start);\n                const ms = seconds * 1000 + nanoseconds * 1e-6;\n                const name = path.basename(cliOptions.outFile);\n                console.log(`Compiled ${name} in ${ms.toFixed(2)}ms`);\n              }\n            })\n            .catch(err => {\n              console.error(err.message);\n            });\n        });\n      }\n    } else {\n      util.assertCompilationResult(results, cliOptions.quiet);\n      await output(results.values());\n    }\n  }\n\n  async function stdin() {\n    let code = \"\";\n    process.stdin.setEncoding(\"utf8\");\n    for await (const chunk of process.stdin) {\n      code += chunk;\n    }\n    const res = await util.transform(\n      cliOptions.filename,\n      code,\n      {\n        ...swcOptions,\n        sourceFileName: \"stdin\",\n      },\n      cliOptions.sync,\n      undefined\n    );\n\n    output([res]);\n  }\n\n  if (cliOptions.filenames.length) {\n    await files();\n  } else {\n    await stdin();\n  }\n}\n"],"names":["cliOptions","swcOptions","concatResults","file","results","added","map","SourceMapGenerator","sourceRoot","code","offset","result","consumer","SourceMapConsumer","sources","Set","eachMapping","mapping","add","source","addMapping","generated","line","generatedLine","column","generatedColumn","original","originalLine","originalColumn","forEach","content","sourceContentFor","setSourceContent","split","length","JSON","stringify","output","sourceMapTarget","path","basename","outFile","util","outputFile","sourceMaps","process","stdout","write","Buffer","from","toString","handle","filename","sourceFileName","slash","relative","dirname","compile","sync","getProgram","previousResults","Map","globSources","filenames","includeDotfiles","isCompilableExtension","extensions","set","get","files","keys","delete","err","console","error","message","watch","watcher","watchSources","on","Promise","resolve","then","assertCompilationResult","quiet","values","info","catch","type","start","hrtime","seconds","nanoseconds","ms","name","log","toFixed","stdin","setEncoding","chunk","res","transform","undefined"],"mappings":"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"}